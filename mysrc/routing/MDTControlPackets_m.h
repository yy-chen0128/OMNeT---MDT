//
// Generated file, do not edit! Created by opp_msgtool 6.2 from mysrc/routing/MDTControlPackets.msg.
//

#ifndef __INET_MDTCONTROLPACKETS_M_H
#define __INET_MDTCONTROLPACKETS_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0602
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif


namespace inet {

class MDTControlPacket;
class KeepAlive;
class KeepAliveNotification;
class JoinRequest;
class JoinReply;
class NeighborSetRequest;
class NeighborSetReply;
class NeighborSetNotification;
class CoordsDiscoverRequest;
class CoordsDiscoverReply;
class PacketHolderForNSMessage;
class PacketHolderMessage;

}  // namespace inet

#include "inet/common/INETDefs_m.h" // import inet.common.INETDefs

#include "inet/common/packet/chunk/Chunk_m.h" // import inet.common.packet.chunk.Chunk

#include "inet/common/packet/Packet_m.h" // import inet.common.packet.Packet

#include "inet/networklayer/common/L3Address_m.h" // import inet.networklayer.common.L3Address


namespace inet {

/**
 * Enum generated from <tt>mysrc/routing/MDTControlPackets.msg:12</tt> by opp_msgtool.
 * <pre>
 * enum MDTControlPacketType
 * {
 *     JRQ = 1;
 *     JRP = 2;
 *     NSRQ = 3;
 *     NSRP = 4;
 *     NSN = 5;
 *     IT = 6;
 *     LN = 7;
 *     FN = 8;
 *     KA = 9;
 *     CDQ = 10;
 *     CDP = 11;
 *     KAN = 12;
 * 
 * 	//JRQ_IPv6 = 11;
 *     //JRP_IPv6 = 12;
 *     //NSRQ_IPv6 = 13;
 * 	//NSRP_IPv6 = 14;
 * 	//NSN_IPv6 = 15;
 * 	//IT_IPv6 = 16;
 * 	//LN_IPv6 = 17;
 * 	//FN_IPv6 = 18;
 * 	//KA_IPv6 = 19;
 * 	//CDQ_IPv6 = 20;
 * 	//CDP_IPv6 = 21;
 * 	//KAN_IPv6 = 22;
 * }
 * </pre>
 */
enum MDTControlPacketType {
    JRQ = 1,
    JRP = 2,
    NSRQ = 3,
    NSRP = 4,
    NSN = 5,
    IT = 6,
    LN = 7,
    FN = 8,
    KA = 9,
    CDQ = 10,
    CDP = 11,
    KAN = 12
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MDTControlPacketType& e) { b->pack(static_cast<int>(e)); }
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MDTControlPacketType& e) { int n; b->unpack(n); e = static_cast<MDTControlPacketType>(n); }

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:41</tt> by opp_msgtool.
 * <pre>
 * class MDTControlPacket extends FieldsChunk
 * {
 *     MDTControlPacketType packetType = static_cast<MDTControlPacketType>(-1);       // packet type, stored in one byte
 * }
 * </pre>
 */
class MDTControlPacket : public ::inet::FieldsChunk
{
  protected:
    MDTControlPacketType packetType = static_cast<MDTControlPacketType>(-1);

  private:
    void copy(const MDTControlPacket& other);

  protected:
    bool operator==(const MDTControlPacket&) = delete;

  public:
    MDTControlPacket();
    MDTControlPacket(const MDTControlPacket& other);
    virtual ~MDTControlPacket();
    MDTControlPacket& operator=(const MDTControlPacket& other);
    virtual MDTControlPacket *dup() const override {return new MDTControlPacket(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual MDTControlPacketType getPacketType() const;
    virtual void setPacketType(MDTControlPacketType packetType);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const MDTControlPacket& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, MDTControlPacket& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:45</tt> by opp_msgtool.
 * <pre>
 * class KeepAlive extends MDTControlPacket
 * {
 *     //L3Address sourceAddr;
 *     //simtime_t timestamp;
 *     \@customize(true);
 *     double coords[];
 *     //int dim;
 *     bool attached;
 * }
 * </pre>
 *
 * KeepAlive_Base is only useful if it gets subclassed, and KeepAlive is derived from it.
 * The minimum code to be written for KeepAlive is the following:
 *
 * <pre>
 * class KeepAlive : public KeepAlive_Base
 * {
 *   private:
 *     void copy(const KeepAlive& other) { ... }

 *   public:
 *     KeepAlive() : KeepAlive_Base() {}
 *     KeepAlive(const KeepAlive& other) : KeepAlive_Base(other) {copy(other);}
 *     KeepAlive& operator=(const KeepAlive& other) {if (this==&other) return *this; KeepAlive_Base::operator=(other); copy(other); return *this;}
 *     virtual KeepAlive *dup() const override {return new KeepAlive(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from KeepAlive_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(KeepAlive)
 * </pre>
 */
class KeepAlive_Base : public ::inet::MDTControlPacket
{
  protected:
    double *coords = nullptr;
    size_t coords_arraysize = 0;
    bool attached = false;

  private:
    void copy(const KeepAlive_Base& other);

  protected:
    bool operator==(const KeepAlive_Base&) = delete;
    // make constructors protected to avoid instantiation
    KeepAlive_Base();
    KeepAlive_Base(const KeepAlive_Base& other);
    // make assignment operator protected to force the user override it
    KeepAlive_Base& operator=(const KeepAlive_Base& other);

  public:
    virtual ~KeepAlive_Base();
    virtual KeepAlive_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class KeepAlive");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setCoordsArraySize(size_t size);
    virtual size_t getCoordsArraySize() const;
    virtual double getCoords(size_t k) const;
    virtual void setCoords(size_t k, double coords);
    virtual void insertCoords(size_t k, double coords);
    [[deprecated]] void insertCoords(double coords) {appendCoords(coords);}
    virtual void appendCoords(double coords);
    virtual void eraseCoords(size_t k);

    virtual bool getAttached() const;
    virtual void setAttached(bool attached);
};

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:53</tt> by opp_msgtool.
 * <pre>
 * class KeepAliveNotification extends MDTControlPacket
 * {
 *     double coords[];
 *     //int dim;
 *     bool attached;
 * }
 * </pre>
 */
class KeepAliveNotification : public ::inet::MDTControlPacket
{
  protected:
    double *coords = nullptr;
    size_t coords_arraysize = 0;
    bool attached = false;

  private:
    void copy(const KeepAliveNotification& other);

  protected:
    bool operator==(const KeepAliveNotification&) = delete;

  public:
    KeepAliveNotification();
    KeepAliveNotification(const KeepAliveNotification& other);
    virtual ~KeepAliveNotification();
    KeepAliveNotification& operator=(const KeepAliveNotification& other);
    virtual KeepAliveNotification *dup() const override {return new KeepAliveNotification(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setCoordsArraySize(size_t size);
    virtual size_t getCoordsArraySize() const;
    virtual double getCoords(size_t k) const;
    virtual void setCoords(size_t k, double coords);
    virtual void insertCoords(size_t k, double coords);
    [[deprecated]] void insertCoords(double coords) {appendCoords(coords);}
    virtual void appendCoords(double coords);
    virtual void eraseCoords(size_t k);

    virtual bool getAttached() const;
    virtual void setAttached(bool attached);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const KeepAliveNotification& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, KeepAliveNotification& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:58</tt> by opp_msgtool.
 * <pre>
 * class JoinRequest extends MDTControlPacket
 * {
 *     double coords[];
 *     //Coordinate nodeCoord;
 *     int dim;
 *     L3Address destAddr;
 *     L3Address sourceAddr;
 *     L3Address predAddr;
 * }
 * </pre>
 */
class JoinRequest : public ::inet::MDTControlPacket
{
  protected:
    double *coords = nullptr;
    size_t coords_arraysize = 0;
    int dim = 0;
    L3Address destAddr;
    L3Address sourceAddr;
    L3Address predAddr;

  private:
    void copy(const JoinRequest& other);

  protected:
    bool operator==(const JoinRequest&) = delete;

  public:
    JoinRequest();
    JoinRequest(const JoinRequest& other);
    virtual ~JoinRequest();
    JoinRequest& operator=(const JoinRequest& other);
    virtual JoinRequest *dup() const override {return new JoinRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setCoordsArraySize(size_t size);
    virtual size_t getCoordsArraySize() const;
    virtual double getCoords(size_t k) const;
    virtual void setCoords(size_t k, double coords);
    virtual void insertCoords(size_t k, double coords);
    [[deprecated]] void insertCoords(double coords) {appendCoords(coords);}
    virtual void appendCoords(double coords);
    virtual void eraseCoords(size_t k);

    virtual int getDim() const;
    virtual void setDim(int dim);

    virtual const L3Address& getDestAddr() const;
    virtual L3Address& getDestAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<JoinRequest*>(this)->getDestAddr());}
    virtual void setDestAddr(const L3Address& destAddr);

    virtual const L3Address& getSourceAddr() const;
    virtual L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<JoinRequest*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const L3Address& sourceAddr);

    virtual const L3Address& getPredAddr() const;
    virtual L3Address& getPredAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<JoinRequest*>(this)->getPredAddr());}
    virtual void setPredAddr(const L3Address& predAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const JoinRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, JoinRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:66</tt> by opp_msgtool.
 * <pre>
 * class JoinReply extends MDTControlPacket
 * {
 *     \@customize(true);
 *     L3Address sourceAddr;
 *     L3Address predAddr;
 *     L3Address destAddr;
 * }
 * </pre>
 *
 * JoinReply_Base is only useful if it gets subclassed, and JoinReply is derived from it.
 * The minimum code to be written for JoinReply is the following:
 *
 * <pre>
 * class JoinReply : public JoinReply_Base
 * {
 *   private:
 *     void copy(const JoinReply& other) { ... }

 *   public:
 *     JoinReply() : JoinReply_Base() {}
 *     JoinReply(const JoinReply& other) : JoinReply_Base(other) {copy(other);}
 *     JoinReply& operator=(const JoinReply& other) {if (this==&other) return *this; JoinReply_Base::operator=(other); copy(other); return *this;}
 *     virtual JoinReply *dup() const override {return new JoinReply(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from JoinReply_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(JoinReply)
 * </pre>
 */
class JoinReply_Base : public ::inet::MDTControlPacket
{
  protected:
    L3Address sourceAddr;
    L3Address predAddr;
    L3Address destAddr;

  private:
    void copy(const JoinReply_Base& other);

  protected:
    bool operator==(const JoinReply_Base&) = delete;
    // make constructors protected to avoid instantiation
    JoinReply_Base();
    JoinReply_Base(const JoinReply_Base& other);
    // make assignment operator protected to force the user override it
    JoinReply_Base& operator=(const JoinReply_Base& other);

  public:
    virtual ~JoinReply_Base();
    virtual JoinReply_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class JoinReply");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getSourceAddr() const;
    virtual L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<JoinReply_Base*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const L3Address& sourceAddr);

    virtual const L3Address& getPredAddr() const;
    virtual L3Address& getPredAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<JoinReply_Base*>(this)->getPredAddr());}
    virtual void setPredAddr(const L3Address& predAddr);

    virtual const L3Address& getDestAddr() const;
    virtual L3Address& getDestAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<JoinReply_Base*>(this)->getDestAddr());}
    virtual void setDestAddr(const L3Address& destAddr);
};

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:72</tt> by opp_msgtool.
 * <pre>
 * class NeighborSetRequest extends MDTControlPacket
 * {
 *     double coords[];
 *     //Coordinate nodeCoord;
 *     int dim;
 *     L3Address sourceAddr;
 *     L3Address destAddr;
 *     L3Address predAddr;
 * }
 * </pre>
 */
class NeighborSetRequest : public ::inet::MDTControlPacket
{
  protected:
    double *coords = nullptr;
    size_t coords_arraysize = 0;
    int dim = 0;
    L3Address sourceAddr;
    L3Address destAddr;
    L3Address predAddr;

  private:
    void copy(const NeighborSetRequest& other);

  protected:
    bool operator==(const NeighborSetRequest&) = delete;

  public:
    NeighborSetRequest();
    NeighborSetRequest(const NeighborSetRequest& other);
    virtual ~NeighborSetRequest();
    NeighborSetRequest& operator=(const NeighborSetRequest& other);
    virtual NeighborSetRequest *dup() const override {return new NeighborSetRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setCoordsArraySize(size_t size);
    virtual size_t getCoordsArraySize() const;
    virtual double getCoords(size_t k) const;
    virtual void setCoords(size_t k, double coords);
    virtual void insertCoords(size_t k, double coords);
    [[deprecated]] void insertCoords(double coords) {appendCoords(coords);}
    virtual void appendCoords(double coords);
    virtual void eraseCoords(size_t k);

    virtual int getDim() const;
    virtual void setDim(int dim);

    virtual const L3Address& getSourceAddr() const;
    virtual L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetRequest*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const L3Address& sourceAddr);

    virtual const L3Address& getDestAddr() const;
    virtual L3Address& getDestAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetRequest*>(this)->getDestAddr());}
    virtual void setDestAddr(const L3Address& destAddr);

    virtual const L3Address& getPredAddr() const;
    virtual L3Address& getPredAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetRequest*>(this)->getPredAddr());}
    virtual void setPredAddr(const L3Address& predAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NeighborSetRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NeighborSetRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:80</tt> by opp_msgtool.
 * <pre>
 * class NeighborSetReply extends MDTControlPacket
 * {
 *     \@customize(true);
 *     L3Address sourceAddr;
 *     L3Address predAddr;
 *     L3Address destAddr;
 * }
 * </pre>
 *
 * NeighborSetReply_Base is only useful if it gets subclassed, and NeighborSetReply is derived from it.
 * The minimum code to be written for NeighborSetReply is the following:
 *
 * <pre>
 * class NeighborSetReply : public NeighborSetReply_Base
 * {
 *   private:
 *     void copy(const NeighborSetReply& other) { ... }

 *   public:
 *     NeighborSetReply() : NeighborSetReply_Base() {}
 *     NeighborSetReply(const NeighborSetReply& other) : NeighborSetReply_Base(other) {copy(other);}
 *     NeighborSetReply& operator=(const NeighborSetReply& other) {if (this==&other) return *this; NeighborSetReply_Base::operator=(other); copy(other); return *this;}
 *     virtual NeighborSetReply *dup() const override {return new NeighborSetReply(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from NeighborSetReply_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(NeighborSetReply)
 * </pre>
 */
class NeighborSetReply_Base : public ::inet::MDTControlPacket
{
  protected:
    L3Address sourceAddr;
    L3Address predAddr;
    L3Address destAddr;

  private:
    void copy(const NeighborSetReply_Base& other);

  protected:
    bool operator==(const NeighborSetReply_Base&) = delete;
    // make constructors protected to avoid instantiation
    NeighborSetReply_Base();
    NeighborSetReply_Base(const NeighborSetReply_Base& other);
    // make assignment operator protected to force the user override it
    NeighborSetReply_Base& operator=(const NeighborSetReply_Base& other);

  public:
    virtual ~NeighborSetReply_Base();
    virtual NeighborSetReply_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class NeighborSetReply");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getSourceAddr() const;
    virtual L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetReply_Base*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const L3Address& sourceAddr);

    virtual const L3Address& getPredAddr() const;
    virtual L3Address& getPredAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetReply_Base*>(this)->getPredAddr());}
    virtual void setPredAddr(const L3Address& predAddr);

    virtual const L3Address& getDestAddr() const;
    virtual L3Address& getDestAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetReply_Base*>(this)->getDestAddr());}
    virtual void setDestAddr(const L3Address& destAddr);
};

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:86</tt> by opp_msgtool.
 * <pre>
 * class NeighborSetNotification extends MDTControlPacket
 * {
 *     double coords[];
 *     int dim;
 *     L3Address sourceAddr;
 *     L3Address predAddr;
 *     L3Address destAddr;
 * }
 * </pre>
 */
class NeighborSetNotification : public ::inet::MDTControlPacket
{
  protected:
    double *coords = nullptr;
    size_t coords_arraysize = 0;
    int dim = 0;
    L3Address sourceAddr;
    L3Address predAddr;
    L3Address destAddr;

  private:
    void copy(const NeighborSetNotification& other);

  protected:
    bool operator==(const NeighborSetNotification&) = delete;

  public:
    NeighborSetNotification();
    NeighborSetNotification(const NeighborSetNotification& other);
    virtual ~NeighborSetNotification();
    NeighborSetNotification& operator=(const NeighborSetNotification& other);
    virtual NeighborSetNotification *dup() const override {return new NeighborSetNotification(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setCoordsArraySize(size_t size);
    virtual size_t getCoordsArraySize() const;
    virtual double getCoords(size_t k) const;
    virtual void setCoords(size_t k, double coords);
    virtual void insertCoords(size_t k, double coords);
    [[deprecated]] void insertCoords(double coords) {appendCoords(coords);}
    virtual void appendCoords(double coords);
    virtual void eraseCoords(size_t k);

    virtual int getDim() const;
    virtual void setDim(int dim);

    virtual const L3Address& getSourceAddr() const;
    virtual L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetNotification*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const L3Address& sourceAddr);

    virtual const L3Address& getPredAddr() const;
    virtual L3Address& getPredAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetNotification*>(this)->getPredAddr());}
    virtual void setPredAddr(const L3Address& predAddr);

    virtual const L3Address& getDestAddr() const;
    virtual L3Address& getDestAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<NeighborSetNotification*>(this)->getDestAddr());}
    virtual void setDestAddr(const L3Address& destAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const NeighborSetNotification& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, NeighborSetNotification& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:93</tt> by opp_msgtool.
 * <pre>
 * class CoordsDiscoverRequest extends MDTControlPacket
 * {
 *     //L3Address destAddr;
 *     //int num;
 *     L3Address sourceAddr;
 *     L3Address targetAddr;
 *     int hopcount;
 * }
 * </pre>
 */
class CoordsDiscoverRequest : public ::inet::MDTControlPacket
{
  protected:
    L3Address sourceAddr;
    L3Address targetAddr;
    int hopcount = 0;

  private:
    void copy(const CoordsDiscoverRequest& other);

  protected:
    bool operator==(const CoordsDiscoverRequest&) = delete;

  public:
    CoordsDiscoverRequest();
    CoordsDiscoverRequest(const CoordsDiscoverRequest& other);
    virtual ~CoordsDiscoverRequest();
    CoordsDiscoverRequest& operator=(const CoordsDiscoverRequest& other);
    virtual CoordsDiscoverRequest *dup() const override {return new CoordsDiscoverRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getSourceAddr() const;
    virtual L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<CoordsDiscoverRequest*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const L3Address& sourceAddr);

    virtual const L3Address& getTargetAddr() const;
    virtual L3Address& getTargetAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<CoordsDiscoverRequest*>(this)->getTargetAddr());}
    virtual void setTargetAddr(const L3Address& targetAddr);

    virtual int getHopcount() const;
    virtual void setHopcount(int hopcount);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CoordsDiscoverRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CoordsDiscoverRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:100</tt> by opp_msgtool.
 * <pre>
 * class CoordsDiscoverReply extends MDTControlPacket
 * {
 *     \@customize(true);
 *     L3Address destAddr;
 *     L3Address sourceAddr;
 *     L3Address targetAddr;
 * }
 * //class InitializationToken extends MDTControlPacket{
 * 
 * ///}
 * //class LeaveNotification extends MDTControlPacket{
 * 
 * //}
 * //class FailureNotification extends MDTControlPacket{
 * 
 * //}
 * </pre>
 *
 * CoordsDiscoverReply_Base is only useful if it gets subclassed, and CoordsDiscoverReply is derived from it.
 * The minimum code to be written for CoordsDiscoverReply is the following:
 *
 * <pre>
 * class CoordsDiscoverReply : public CoordsDiscoverReply_Base
 * {
 *   private:
 *     void copy(const CoordsDiscoverReply& other) { ... }

 *   public:
 *     CoordsDiscoverReply() : CoordsDiscoverReply_Base() {}
 *     CoordsDiscoverReply(const CoordsDiscoverReply& other) : CoordsDiscoverReply_Base(other) {copy(other);}
 *     CoordsDiscoverReply& operator=(const CoordsDiscoverReply& other) {if (this==&other) return *this; CoordsDiscoverReply_Base::operator=(other); copy(other); return *this;}
 *     virtual CoordsDiscoverReply *dup() const override {return new CoordsDiscoverReply(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from CoordsDiscoverReply_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(CoordsDiscoverReply)
 * </pre>
 */
class CoordsDiscoverReply_Base : public ::inet::MDTControlPacket
{
  protected:
    L3Address destAddr;
    L3Address sourceAddr;
    L3Address targetAddr;

  private:
    void copy(const CoordsDiscoverReply_Base& other);

  protected:
    bool operator==(const CoordsDiscoverReply_Base&) = delete;
    // make constructors protected to avoid instantiation
    CoordsDiscoverReply_Base();
    CoordsDiscoverReply_Base(const CoordsDiscoverReply_Base& other);
    // make assignment operator protected to force the user override it
    CoordsDiscoverReply_Base& operator=(const CoordsDiscoverReply_Base& other);

  public:
    virtual ~CoordsDiscoverReply_Base();
    virtual CoordsDiscoverReply_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class CoordsDiscoverReply");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const L3Address& getDestAddr() const;
    virtual L3Address& getDestAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<CoordsDiscoverReply_Base*>(this)->getDestAddr());}
    virtual void setDestAddr(const L3Address& destAddr);

    virtual const L3Address& getSourceAddr() const;
    virtual L3Address& getSourceAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<CoordsDiscoverReply_Base*>(this)->getSourceAddr());}
    virtual void setSourceAddr(const L3Address& sourceAddr);

    virtual const L3Address& getTargetAddr() const;
    virtual L3Address& getTargetAddrForUpdate() { handleChange();return const_cast<L3Address&>(const_cast<CoordsDiscoverReply_Base*>(this)->getTargetAddr());}
    virtual void setTargetAddr(const L3Address& targetAddr);
};

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:120</tt> by opp_msgtool.
 * <pre>
 * //
 * // Represents a timer for delayed sending
 * //
 * message PacketHolderForNSMessage//not use
 * {
 *     Packet *ownedPacket \@owned;
 *     L3Address nsrqSrcAddr;
 *     L3Address nsrqDestAddr;
 * }
 * </pre>
 */
class PacketHolderForNSMessage : public ::omnetpp::cMessage
{
  protected:
    Packet * ownedPacket = nullptr;
    L3Address nsrqSrcAddr;
    L3Address nsrqDestAddr;

  private:
    void copy(const PacketHolderForNSMessage& other);

  protected:
    bool operator==(const PacketHolderForNSMessage&) = delete;

  public:
    PacketHolderForNSMessage(const char *name=nullptr, short kind=0);
    PacketHolderForNSMessage(const PacketHolderForNSMessage& other);
    virtual ~PacketHolderForNSMessage();
    PacketHolderForNSMessage& operator=(const PacketHolderForNSMessage& other);
    virtual PacketHolderForNSMessage *dup() const override {return new PacketHolderForNSMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const Packet * getOwnedPacket() const;
    virtual Packet * getOwnedPacketForUpdate() { return const_cast<Packet *>(const_cast<PacketHolderForNSMessage*>(this)->getOwnedPacket());}
    virtual void setOwnedPacket(Packet * ownedPacket);
    virtual Packet * removeOwnedPacket();
    [[deprecated]] Packet * dropOwnedPacket() {return removeOwnedPacket();}

    virtual const L3Address& getNsrqSrcAddr() const;
    virtual L3Address& getNsrqSrcAddrForUpdate() { return const_cast<L3Address&>(const_cast<PacketHolderForNSMessage*>(this)->getNsrqSrcAddr());}
    virtual void setNsrqSrcAddr(const L3Address& nsrqSrcAddr);

    virtual const L3Address& getNsrqDestAddr() const;
    virtual L3Address& getNsrqDestAddrForUpdate() { return const_cast<L3Address&>(const_cast<PacketHolderForNSMessage*>(this)->getNsrqDestAddr());}
    virtual void setNsrqDestAddr(const L3Address& nsrqDestAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PacketHolderForNSMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PacketHolderForNSMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>mysrc/routing/MDTControlPackets.msg:126</tt> by opp_msgtool.
 * <pre>
 * message PacketHolderMessage
 * {
 *     Packet *ownedPacket \@owned;
 *     L3Address destAddr;
 * }
 * </pre>
 */
class PacketHolderMessage : public ::omnetpp::cMessage
{
  protected:
    Packet * ownedPacket = nullptr;
    L3Address destAddr;

  private:
    void copy(const PacketHolderMessage& other);

  protected:
    bool operator==(const PacketHolderMessage&) = delete;

  public:
    PacketHolderMessage(const char *name=nullptr, short kind=0);
    PacketHolderMessage(const PacketHolderMessage& other);
    virtual ~PacketHolderMessage();
    PacketHolderMessage& operator=(const PacketHolderMessage& other);
    virtual PacketHolderMessage *dup() const override {return new PacketHolderMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual const Packet * getOwnedPacket() const;
    virtual Packet * getOwnedPacketForUpdate() { return const_cast<Packet *>(const_cast<PacketHolderMessage*>(this)->getOwnedPacket());}
    virtual void setOwnedPacket(Packet * ownedPacket);
    virtual Packet * removeOwnedPacket();
    [[deprecated]] Packet * dropOwnedPacket() {return removeOwnedPacket();}

    virtual const L3Address& getDestAddr() const;
    virtual L3Address& getDestAddrForUpdate() { return const_cast<L3Address&>(const_cast<PacketHolderMessage*>(this)->getDestAddr());}
    virtual void setDestAddr(const L3Address& destAddr);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PacketHolderMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PacketHolderMessage& obj) {obj.parsimUnpack(b);}


}  // namespace inet


namespace omnetpp {

template<> inline inet::MDTControlPacket *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::MDTControlPacket*>(ptr.get<cObject>()); }
template<> inline inet::KeepAlive_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::KeepAlive_Base*>(ptr.get<cObject>()); }
template<> inline inet::KeepAliveNotification *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::KeepAliveNotification*>(ptr.get<cObject>()); }
template<> inline inet::JoinRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::JoinRequest*>(ptr.get<cObject>()); }
template<> inline inet::JoinReply_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::JoinReply_Base*>(ptr.get<cObject>()); }
template<> inline inet::NeighborSetRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::NeighborSetRequest*>(ptr.get<cObject>()); }
template<> inline inet::NeighborSetReply_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::NeighborSetReply_Base*>(ptr.get<cObject>()); }
template<> inline inet::NeighborSetNotification *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::NeighborSetNotification*>(ptr.get<cObject>()); }
template<> inline inet::CoordsDiscoverRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::CoordsDiscoverRequest*>(ptr.get<cObject>()); }
template<> inline inet::CoordsDiscoverReply_Base *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::CoordsDiscoverReply_Base*>(ptr.get<cObject>()); }
template<> inline inet::PacketHolderForNSMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::PacketHolderForNSMessage*>(ptr.get<cObject>()); }
template<> inline inet::PacketHolderMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<inet::PacketHolderMessage*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __INET_MDTCONTROLPACKETS_M_H

